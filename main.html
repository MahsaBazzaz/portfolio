<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>When a Single Tile Breaks Everything: Game Level Robustness</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #fafafa;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 60px 20px;
            background: linear-gradient(135deg, #575d7b 0%, #381e53 100%);
            color: white;
            margin-bottom: 40px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .authors {
            margin-top: 20px;
            font-size: 1.1em;
        }
        
        section {
            background: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }
        
        h2 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 2em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #444;
            margin: 30px 0 15px 0;
            font-size: 1.4em;
        }
        
        .demo-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .demo-box {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        
        .demo-box h4 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.1em;
        }
        
        .level-canvas {
            display: inline-block;
            border: 1px solid #ddd;
            background: #f8f9fa;
            margin: 10px 0;
            cursor: pointer;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .controls {
            margin-top: 15px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 0 5px;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #764ba2;
        }
        
        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
        }
        
        .status {
            margin-top: 10px;
            font-weight: 600;
            padding: 8px;
            border-radius: 4px;
        }
        
        .status.solvable {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .status.unsolvable {
            background: #fed7d7;
            color: #742a2a;
        }
        
        .game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .game-card {
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        
        .plot-container {
            margin: 30px 0;
            min-height: 400px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            background: #fcfcfc;
        }
        
        .slider-container {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .note-box {
            background: #fef5e7;
            border-left: 4px solid #f39c12;
            padding: 20px;
            margin: 30px 0;
            border-radius: 4px;
        }
        
        .note-box h4 {
            color: #e67e22;
            margin-bottom: 10px;
        }
        
        .links-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .link-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            text-decoration: none;
            transition: transform 0.3s;
        }
        
        .link-card:hover {
            transform: scale(1.05);
        }
        
        .link-card i {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        @media (max-width: 768px) {
            .demo-container {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            section {
                padding: 20px;
            }
        }
        
        /* Animation for path visualization */
        @keyframes pulse {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }
        
        .path-tile {
            animation: pulse 1s infinite;
        }
        
        /* Code highlighting */
        .code-snippet {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }

    .formula-box {
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        border-left: 4px solid #6366f1;
        padding: 1.5rem 2rem;
        margin: 1.5rem 0;
        border-radius: 0 8px 8px 0;
        overflow-x: auto;
    }
    
    .formula-box .formula-label {
        font-family: 'Helvetica Neue', sans-serif;
        font-size: 0.85em;
        font-weight: 600;
        color: #6366f1;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 0.75rem;
    }
    
    .formula-box .formula-content {
        font-size: 1.1em;
        text-align: center;
        padding: 0.5rem 0;
    }
    
    .intuition-note {
        background: #fffbeb;
        border: 1px solid #fcd34d;
        padding: 1rem 1.25rem;
        border-radius: 8px;
        margin: 1rem 0;
        font-size: 0.95em;
    }
    
    .intuition-note strong {
        color: #b45309;
    }
    
    .key-insight {
        background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
        border: 1px solid #34d399;
        padding: 1.25rem 1.5rem;
        border-radius: 8px;
        margin: 1.5rem 0;
    }
    
    .key-insight h4 {
        color: #047857;
        margin: 0 0 0.5rem 0;
        font-size: 1em;
    }
    
    .comparison-table {
        width: 100%;
        margin: 1.5rem 0;
        border-collapse: collapse;
    }
    
    .comparison-table th, .comparison-table td {
        padding: 0.75rem 1rem;
        text-align: left;
        border-bottom: 1px solid #e2e8f0;
    }
    
    .comparison-table th {
        background: #f8fafc;
        font-weight: 600;
        color: #475569;
    }
    
    .highlight-text {
        background: linear-gradient(120deg, #fef3c7 0%, #fde68a 100%);
        padding: 0 4px;
        border-radius: 2px;
    }
    .results-table {
        width: 100%;
        border-collapse: collapse;
        margin: 1.5rem 0;
        font-size: 0.95em;
    }
    
    .results-table th,
    .results-table td {
        padding: 0.75rem 1rem;
        text-align: left;
        border-bottom: 1px solid #e2e8f0;
    }
    
    .results-table th {
        background: #f8fafc;
        font-weight: 600;
        color: #475569;
        border-bottom: 2px solid #cbd5e1;
    }
    
    .results-table tbody tr:hover {
        background: #f8fafc;
    }
    
    .results-table .highlight-cell {
        background: #fef2f2;
        color: #dc2626;
        font-weight: 600;
    }
    
    .plot-container {
        width: 100%;
        min-height: 400px;
        margin: 1.5rem 0;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #fafafa;
    }
    
    #results p {
        line-height: 1.8;
        margin-bottom: 1rem;
    }
    
    #results h3 {
        margin-top: 2.5rem;
        margin-bottom: 1rem;
        color: #1a202c;
    }

    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <header>
        <h1>Analysis of Robustness of a Large Game Corpus</h1>
        <div class="authors">Mahsa Bazzaz & Seth CooperÂ· FDG 2025</div>
    </header>

    <div class="container">
        <!-- Section 1: Structured Discrete Data -->
        <section id="structured-data">
            <h2>1. The Fragility of Structured Discrete Data</h2>
            
            <p><strong>"Bad data"</strong> often arises when real-world information fails to conform to predefined rules or constraints, causing breakdowns in how that information is processed and interpreted. In the case of highly structured discrete data, these constraints can be especially unforgiving: even a minor deviation from expected formats can cause complete failure.</p>

            <h3>Sensitivity to small changes in different data types</h3>
            
            <p>Consider how differently various data types respond to small changes:</p>

            <div class="comparison-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 30px 0;">
                <div class="comparison-box" style="padding: 20px; background: #f0f7ff; border-radius: 8px;">
                    <h4 style="color: #2563eb; margin-bottom: 15px;"> Traditional Images (CIFAR-10, ImageNet)</h4>
                    <div style="background: white; padding: 15px; border-radius: 4px; margin-bottom: 15px;">
                        <canvas id="adversarial-demo" width="300" height="150"></canvas>
                        <p style="font-size: 0.9em; color: #666; margin-top: 10px; text-align: center;">
                            Even with carefully crafted adversarial noise affecting <strong>thousands of pixels</strong>,<br>
                            a panda is still recognizably a panda to humans
                        </p>
                    </div>
                    <ul style="list-style: none; padding: 0;">
                        <br>
                        <li><strong>Pixel</strong>: Smallest visual element (165536 in a 256Ã—256 image)</li>
                        <li><strong>Redundancy</strong>: Adjacent pixels often similar</li>
                        <li><strong>Continuity</strong>: Small changes â†’ small effects</li>
                        <li><strong>Outcome</strong>: Robust to noise</li>
                    </ul>
                </div>

                <div class="comparison-box" style="padding: 20px; background: #fef3f2; border-radius: 8px;">
                    <h4 style="color: #dc2626; margin-bottom: 15px;">Game Levels (Structured Discrete)</h4>
                    <div style="background: white; padding: 15px; border-radius: 4px; margin-bottom: 15px;">
                        <canvas id="maze-comparison" width="300" height="150"></canvas>
                        
                        <p style="font-size: 0.9em; color: #666; margin-top: 10px; text-align: center;">
                            Adding <strong>just one wall tile</strong> (shown in red)<br>
                            completely blocks the only path to the goal
                        </p>
                        <br>
                        <br>
                    </div>
                    <ul style="list-style: none; padding: 0;">
                        <li><strong>Tile</strong>: Functional building block with gameplay mechanics</li>
                        <li><strong>Constraints</strong>: Each tile must satisfy local & global rules</li>
                        <li><strong>Brittleness</strong>: Small changes â†’ big effects</li>
                        <li><strong>Outcome</strong>: playable or unplayble</li>
                    </ul>
                </div>
            </div>

            <p>This distinction is crucial. In game levels, a <strong>"tile"</strong> is the smallest building block that constructs both the visual and functional layout of a game's environment, with each tile corresponding to specific gameplay mechanics or aesthetics (walls block movement, keys unlock doors, spikes harm the player). Unlike pixels in images, tiles have <strong>semantic meaning and mechanical function</strong>.</p>

            <h3>Understanding Constraints in Structured Data</h3>
            
            <p>Structured discrete data, whether game levels or other domains, must satisfy various types of constraints. Understanding these constraints is crucial for developing effective generation models:</p>

            <div style="background: #f0f4f8; padding: 25px; border-radius: 12px; margin: 20px 0;">
                <h4 style="color: #1e40af; margin-bottom: 20px;">Types of Constraints</h4>
                
                <!-- Hard vs Soft Constraints -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
                    <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #28a745;">
                        <h5 style="color: #28a745; margin-bottom: 15px;">Hard Constraints</h5>
                        <p style="margin: 0; color: #495057;">
                            <strong>Definition:</strong> Mandatory conditions that MUST be satisfied for validity. Violation means complete failure.
                        </p>
                        <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #6c757d;">
                            In constraint satisfaction problems (CSP), these are non-negotiable requirements that cannot be relaxed.
                        </p>
                    </div>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #ffc107;">
                        <h5 style="color: #f57c00; margin-bottom: 15px;">Soft Constraints</h5>
                        <p style="margin: 0; color: #495057;">
                            <strong>Definition:</strong> Preferred conditions that SHOULD be satisfied for quality. Violation reduces desirability but not validity.
                        </p>
                        <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #6c757d;">
                            These can be treated as optimization objectives with penalties proportional to violation degree.
                        </p>
                    </div>
                </div>

                <!-- Local vs Global Constraints -->
                <h4 style="color: #1e40af; margin: 25px 0 20px 0;">Scope of Constraints</h4>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #9333ea;">
                        <h5 style="color: #7c3aed; margin-bottom: 15px;">Local Constraints</h5>
                        <p style="margin: 0; color: #495057;">
                            <strong>Definition:</strong> Rules governing relationships between neighboring or nearby elements.
                        </p>
                        <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #6c757d;">
                            These ensure proper patterns and connections at the micro-level, affecting small regions of the structure.
                        </p>
                    </div>
                    
                    <div style="background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #0ea5e9;">
                        <h5 style="color: #0284c7; margin-bottom: 15px;">Global Constraints</h5>
                        <p style="margin: 0; color: #495057;">
                            <strong>Definition:</strong> Rules governing properties of the entire structure as a whole.
                        </p>
                        <p style="margin: 10px 0 0 0; font-size: 0.9em; color: #6c757d;">
                            These ensure overall correctness and completeness, requiring analysis of the full structure to verify.
                        </p>
                    </div>
                </div>
                
                <div class="note-box" style="margin-top: 20px; background: #fef3c7; border-left-color: #f59e0b;">
                    <h4 style="color: #d97706;">The Interaction Effect</h4>
                    <p style="margin-bottom: 10px;">These constraint dimensions combine to create four distinct categories:</p>
                    <ul style="margin-left: 20px;">
                        <li><strong>Hard + Local:</strong> Solid ground tiles must exist under the player spawn point</li>
                        <li><strong>Hard + Global:</strong> Level must be solvable from start to goal</li>
                        <li><strong>Soft + Local:</strong> Decorative elements should follow aesthetic patterns</li>
                        <li><strong>Soft + Global:</strong> Overall difficulty should progress smoothly</li>
                    </ul>
                </div>
            </div>

            <h3>When Local Constraints Break: Visual Examples</h3>
            
            <p>Beyond global solvability, game levels must also satisfy <strong>local constraints</strong> - structural patterns that ensure visual and functional coherence. Even state-of-the-art models frequently violate these, producing "broken" content that looks wrong even if technically solvable:</p>

            <div style="background: white; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                    <div style="text-align: center; margin-bottom: 20px;">
                        <img src="./resources/local_constraint.png" alt="Description of the resource image a.png" style="max-width: 100%; height: auto; border-radius: 4px;">
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 15px;">
                        <div style="text-align: center;">
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                <strong>Cave:</strong> Broken decoration pattern in a maze<br>
                                (isolated corner piece)
                            </p>
                        </div>
                        <div style="text-align: center;">
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                <strong>Platform:</strong> Incomplete pipe structure in a platformer<br>
                                (pipe doesn't connect properly)
                            </p>
                        </div>
                        <div style="text-align: center;">
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                <strong>Vertical:</strong> Floating decorative element<br>
                                (flower without stem)
                            </p>
                        </div>
                    </div>
                </div>


            <h3>When One Tile Changes Everything</h3>
            
            <p>Let's see this brittleness in action. Below are two platformer levels that differ by <strong>exactly one tile</strong>. In platformers, precise jump distances are crucial - watch how removing a single platform tile creates an impossible gap:</p>
            
            <div class="demo-container">
                <div class="demo-box">
                    <h4>Solvable Level</h4>
                    <canvas id="solvable-level" class="level-canvas" width="320" height="320"></canvas>
                    <div class="controls">
                        <button id="play-solvable">â–¶ Play Solution</button>
                        <button id="reset-solvable">â†» Reset</button>
                    </div>
                    <div class="status solvable">Player can jump across all gaps!</div>
                    <p style="font-size: 0.85em; color: #666; margin-top: 10px;">
                        Maximum jump distance: 3 tiles. All gaps are â‰¤ 3 tiles wide.
                    </p>
                </div>
                
                <div class="demo-box">
                    <h4>Unsolvable Level</h4>
                    <canvas id="unsolvable-level" class="level-canvas" width="320" height="320"></canvas>
                    <div class="controls">
                        <button id="play-unsolvable">â–¶ Try Solution</button>
                        <button id="reset-unsolvable">â†» Reset</button>
                    </div>
                    <div class="status unsolvable">Gap too wide - Level unsolvable!</div>
                    <p style="font-size: 0.85em; color: #666; margin-top: 10px;">
                        Single platform tile removed creates a 4-tile gap - <strong>impossible to jump!</strong>
                    </p>
                </div>
            </div>

            <h3>Why This Matters for Machine Learning</h3>
            
            <p>This extreme sensitivity creates unique challenges for procedural content generation via machine learning (PCGML):</p>
            
            <ol style="margin-left: 20px; line-height: 1.8;">
                <li><strong>Gradient-based learning struggles</strong>: The discrete nature and binary outcomes (solvable/unsolvable) make it difficult to backpropagate meaningful gradients through neural networks.</li>
                <li><strong>No tolerance for errors</strong>: Unlike image generation where slight imperfections are acceptable, a single misplaced tile can render a level unplayable. Even state-of-the-art models like transformers, VAEs, and GANs frequently generate levels with broken local structures (pipes that don't connect, floating platforms, inaccessible areas).</li>
                <li><strong>Training data is sparse</strong>: Unlike millions of images available for computer vision, game level datasets typically contain only hundreds to thousands of examples, making it harder to learn these complex constraints.</li>
            </ol>
        </section>

        <!-- Section 2: Robustness Analysis -->
        <section id="robustness">
            <h3>2. What is Data Robustness?</h3>
    
            <p>
                The idea of <strong>robustness</strong> originally comes from studying classifiersâ€”machine learning models 
                that assign labels to data points. A robust classifier is one that gives the same answer even when 
                the input is slightly perturbed. But here, we flip the question: instead of asking 
                <em>"is the classifier robust?"</em> we ask <em>"is the data itself robust?"</em>
            </p>
            
            <p>
                Think of it this way: if you take a data point and nudge it just a tiny bit, does its 
                <span class="highlight-text">true label</span> change? For most image datasets, the answer is noâ€”a 
                slightly noisy photo of a cat is still a cat. But for game levels, a single tile change can flip 
                a level from solvable to impossible.
            </p>

            <h4>The Original Definition (for Classifiers)</h4>
            
            <p>
                Robustness was first defined to measure how consistently a classifier \(f\) behaves when inputs 
                are slightly perturbed. Given a distribution of data \(\mathcal{D}\) and a distance threshold \(r\), 
                the robustness measures the probability that nearby points get the same predicted label:
            </p>
            
            <div class="formula-box">
                <div class="formula-label">Classifier Robustness</div>
                <div class="formula-content">
                    \[
                    A_r(f, \mathcal{D}) = \mathbb{P}_{x \sim \mathcal{D}}\left[f(x) = f(x') \;\Big|\; \forall x',\, d(x, x') \leq r\right]
                    \]
                </div>
            </div>
            
            <p>
                In plain English: pick a random data point \(x\). Now consider <em>all</em> points \(x'\) within 
                distance \(r\) of it. Robustness is the probability that the classifier gives all of them the 
                same label. High robustness means the classifier is stableâ€”small input changes don't flip predictions.
            </p>

            <h4>Our Twist: Robustness of the Data Itself</h4>
            
            <p>
                We adapt this idea to measure a property of the <em>data</em>, not the classifier. Instead of 
                asking whether a model's predictions stay consistent, we ask whether the <strong>true labels</strong> 
                stay consistent under small perturbations:
            </p>
            
            <div class="formula-box">
                <div class="formula-label">Data Robustness</div>
                <div class="formula-content">
                    \[
                    D_r(\mathcal{D}) = \mathbb{P}_{x \sim \mathcal{D}}\left[\text{Label}(x) = \text{Label}(x') \;\Big|\; \forall x',\, d(x, x') \leq r\right]
                    \]
                </div>
            </div>
            
            <div class="intuition-note">
                <strong>ðŸ’¡ The Key Insight:</strong> We replace the classifier's prediction \(f(x)\) with the 
                ground-truth label. This tells us about the <em>nature of the data</em> itselfâ€”how "fragile" 
                or "stable" the label boundaries are.
            </div>

            <h4>Non-Robustness: Measuring Sensitivity</h4>
            
            <p>
                In practice, it's often more useful to measure the oppositeâ€”<strong>non-robustness</strong>â€”which 
                captures how likely it is that a small change <em>will</em> flip the label:
            </p>
            
            <div class="formula-box">
                <div class="formula-label">Non-Robustness (Our Main Metric)</div>
                <div class="formula-content">
                    \[
                    \text{ND}_r(\mathcal{D}) = \mathbb{P}_{x \sim \mathcal{D}}\left[\text{Label}(x) \neq \text{Label}(x') \;\Big|\; \exists x',\, d(x, x') \leq r\right]
                    \]
                </div>
            </div>
            
            <p>
                This reads as: pick a random data point \(x\). If there <em>exists</em> any nearby point \(x'\) 
                (within distance \(r\)) that has a <em>different</em> label, we count that. Non-robustness is the 
                probability of finding such a label-flipping neighbor.
            </p>
            
            <div class="key-insight">
                <h4>ðŸ“Š Interpreting the Numbers</h4>
                <p>
                    <strong>Higher non-robustness = more sensitive data.</strong> If \(\text{ND}_r(\mathcal{D})\) is 
                    high, it means many data points are "close to the edge"â€”small perturbations can easily change 
                    their labels. For game levels, this manifests as levels that become unsolvable with just one 
                    tile swap.
                </p>
            </div>

            <div class="note-box">
                <h4>Important Distinction</h4>
                <p><strong>Robustness of Data vs. Robustness of Classifier:</strong></p>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li><strong>Data Robustness:</strong> Whether the true label actually changes with input perturbation (our focus)</li>
                    <li><strong>Classifier Robustness:</strong> Whether a model's prediction changes (traditional adversarial ML focus)</li>
                </ul>
                <p style="margin-top: 10px;">For game levels, the ground truth <em>should</em> change when critical tiles are modified - a robust classifier needs to capture this sensitivity!</p>
            </div>
        </section>

        <!-- Section 3: The GGLC Dataset -->
        <section id="gglc-dataset">
            <h2>3. The Generated Game Level Corpus (GGLC)</h2>
            
            <h3>Why We Created It</h3>
            <p>Existing game level datasets are small (typically hundreds of levels) and often copyrighted. We created a large, diverse, and freely available dataset to study these unique features of game level.</p>
            
            <h3>How We Generate Levels: The Sturgeon Engine</h3>
            <p>We use <strong>Sturgeon</strong>, a 2D tile-based level generator that transforms game level generation into binary constraint solving problems.</p>
            <p> You can find Sturgeon codebase in this <a href="https://github.com/crowdgames/sturgeon-pub" target="_blank">Github Repository</a>.</p>

            
            <h3>Our Games Collection</h3>
            <div class="game-display-container" style="max-width: 1000px; margin: 0 auto;">

            <div class="game-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                
                <div class="game-card" style="text-align: center; border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; display: flex; flex-direction: column; justify-content: space-between;">
                    <h4>Cave</h4>
                    <img src="./games/cave.png" alt="Top-down cave maze" class="level-image" 
                        style="width: 100%; height: auto; max-height: 180px; object-fit: contain; border-radius: 4px;">
                    <p>Top-down maze navigation with keys and doors</p>
                    <p><strong>60,000+ levels</strong></p>
                    <a href="https://github.com/TheGGLC/TheGGLC/tree/main/cave" target="_blank" 
                    style="display: inline-block; padding: 10px 20px; text-decoration: none; 
                            background-color: #4CAF50; color: white; border-radius: 5px; 
                            font-weight: bold; /* margin-top: 10px removed */">
                        View Dataset
                    </a>
                </div>
                
                <div class="game-card" style="text-align: center; border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; display: flex; flex-direction: column; justify-content: space-between;">
                    <h4>Platform</h4>
                    <img src="./games/platform.png" alt="Mario-inspired platformer" class="level-image" 
                        style="width: 100%; height: auto; max-height: 250px; object-fit: contain; border-radius: 4px;">
                    <p>Mario-inspired platformer with jumps</p>
                    <p><strong>10,000+ levels</strong></p>
                     <a href="https://github.com/TheGGLC/TheGGLC/tree/main/platform" target="_blank" 
                    style="display: inline-block; padding: 10px 20px; text-decoration: none; 
                            background-color: #4CAF50; color: white; border-radius: 5px; 
                            font-weight: bold; /* margin-top: 10px removed */">
                        View Dataset
                    </a>
                </div>

            </div>

            <div class="game-row" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px;">
                
                <div class="game-card" style="text-align: center; border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; display: flex; flex-direction: column; justify-content: space-between;">
                    <h4>Crates</h4>
                    <img src="./games/soko.png" alt="Sokoban puzzle with crates" class="level-image" 
                        style="width: 100%; height: auto; max-height: 250px; object-fit: contain; border-radius: 4px;">
                    <p>Sokoban-style puzzle pushing boxes</p>
                    <p><strong>10,000+ levels</strong></p>
                    <a href="https://github.com/TheGGLC/TheGGLC/tree/main/crates" target="_blank" 
                    style="display: inline-block; padding: 10px 20px; text-decoration: none; 
                            background-color: #4CAF50; color: white; border-radius: 5px; 
                            font-weight: bold; /* margin-top: 10px removed */">
                        View Dataset
                    </a>
                </div>
                
                <div class="game-card" style="text-align: center; border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; display: flex; flex-direction: column; justify-content: space-between;">
                    <h4>Vertical</h4>
                    <img src="./games/10003.png" alt="Vertical platformer level" class="level-image" 
                        style="width: 100%; height: auto; max-height: 250px; object-fit: contain; border-radius: 4px;">
                    <p>Vertical platformer with wall climbing</p>
                    <p><strong>10,000+ levels</strong></p>
                    <a href="https://github.com/TheGGLC/TheGGLC/tree/main/vertical" target="_blank" 
                    style="display: inline-block; padding: 10px 20px; text-decoration: none; 
                            background-color: #4CAF50; color: white; border-radius: 5px; 
                            font-weight: bold; /* margin-top: 10px removed */">
                        View Dataset
                    </a>
                </div>

                <div class="game-card" style="text-align: center; border: 1px solid #e0e0e0; padding: 15px; border-radius: 8px; display: flex; flex-direction: column; justify-content: space-between;">
                    <h4>Slide</h4>
                    <img src="./games/slide.png" alt="Ice sliding puzzle" class="level-image" 
                        style="width: 100%; height: auto; max-height: 250px; object-fit: contain; border-radius: 4px;">
                    <p>Ice physics navigation puzzle</p>
                    <p><strong>8,000+ levels</strong></p>
                     <a href="https://github.com/TheGGLC/TheGGLC/tree/main/slide" target="_blank" 
                    style="display: inline-block; padding: 10px 20px; text-decoration: none; 
                            background-color: #4CAF50; color: white; border-radius: 5px; 
                            font-weight: bold; /* margin-top: 10px removed */">
                        View Dataset
                    </a>
                </div>

            </div>
        </section>

        <!-- Section 4: Results -->
        <section id="results">
            <h2>4. Experiments</h2>
    
    <p>
        To validate our claim that game levels are fundamentally less robust than traditional ML datasets, 
        we conducted two complementary experiments. The first directly measures the <em>true distribution</em> 
        by exhaustively testing all possible single-tile changes. The second analyzes our <em>generated dataset</em> 
        by embedding levels into a continuous space and measuring how often nearby points have different labels.
    </p>

    <h3>True Distribution: Exhaustive Single-Tile Analysis</h3>
    
    <p>
        For the true distribution experiment, we generated 100 random levels from each game and systematically 
        tested <strong>every possible single-tile replacement</strong>. This gives us the exact probability that 
        a random single-tile change will break a levelâ€”no approximation needed.
    </p>
    <br>
    <p>
        The table below shows what percentage of single-tile changes either 
        break solvability (the level becomes impossible to complete) or break acceptability (the level 
        violates local structural constraints, like broken pipe segments):
    </p>

    <table class="results-table">
        <thead>
            <tr>
                <th>Game</th>
                <th>Changed Solvability</th>
                <th>Changed Acceptability</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Cave</strong></td>
                <td>43.1%</td>
                <td>43.0%</td>
            </tr>
            <tr>
                <td><strong>Platform</strong></td>
                <td>17.1%</td>
                <td>0.1%</td>
            </tr>
            <tr>
                <td><strong>Crates</strong></td>
                <td>78.9%</td>
                <td>0%</td>
            </tr>
            <tr>
                <td><strong>Vertical</strong></td>
                <td>17.5%</td>
                <td>42.5%</td>
            </tr>
        </tbody>
    </table>
    
    <p>
        <strong>Crates</strong> (our Sokoban-style puzzle game) is the most fragile: nearly 4 out of 5 random 
        tile changes break the level. This makes senseâ€”pushing crates into corners or blocking narrow passages 
        easily creates deadlocks. <strong>Cave</strong> levels are also highly sensitive because maze-like 
        structures have many potential chokepoints where a single wall tile can block the only path.
    </p>
    
    <p>
        Compare this to image datasets like CIFAR-10 or MNIST, where changing a single pixel 
        <strong>almost never</strong> changes the true label. A cat with one different pixel is still a cat. 
        But a puzzle level with one different tile might be completely unsolvable.
    </p>

    <h3>Sample Distribution: Embedding-Based Analysis</h3>
    
    <p>
        The exhaustive approach above works for measuring sensitivity to single-tile changes, but how do we 
        compare game levels to image datasets on equal footing? We can't enumerate all single-pixel changes 
        for CIFAR-10 imagesâ€”there are too many pixels and possible values.
    </p>
    
    <p>
        Instead, we embed all data into a shared continuous space using <strong>CLIP</strong> (chosen because 
        <a href="https://dl.acm.org/doi/full/10.1145/3613904.3642077" target="_blank">prior work</a> showed it aligns well 
        with human similarity judgments for game levels), then reduce to 2D with <strong>UMAP</strong>. In this 
        space, we measure non-robustness by checking whether nearby points (within radius \(r\)) have different labels.
    </p>
    
    <p>
        The plot below shows non-robustness across different radius values. Higher values mean the data is 
        more sensitiveâ€”nearby points in embedding space are more likely to have opposite labels:
    </p>

    <div id="robustness-plot" class="plot-container"></div>

    <p>
        <strong>Cave</strong> dominates across the board, with non-robustness reaching 36% even at small perturbation sizes. This aligns with our exhaustive analysis: maze games are inherently brittle. Notice that even <strong>Platform</strong> and <strong>Crates</strong> exceed CIFAR-10 at larger radius values, despite CIFAR-10 having far more "pixels" per sample than our games have tiles.
    </p>

    <h3>Visualizing the Label Boundaries</h3>
    
    <p>
        To see <em>why</em> game levels are less robust, we can visualize the embedding space directly. 
        The plots below show solvable (blue) and unsolvable (red) levels projected into 2D. Notice how 
        the classes overlap and interleaveâ€”there's no clean separation. Hover over points to see actual levels:
    </p>

    <div id="embedding-plot" class="plot-container"></div>
    
    <p>
        The purple regions where classes overlap are exactly where non-robustness is highest. A generative 
        model trying to produce solvable levels must navigate this treacherous landscape where a tiny 
        step in the wrong direction crosses into unsolvable territory.
    </p>
        </section>

        <!-- Section 5: Resources -->
        <section id="resources">
            <h2>5. Learn More</h2>
            
            <div class="links-grid">
                <a href="https://dl.acm.org/doi/pdf/10.1145/3723498.3723820" class="link-card">
                    <i class="fas fa-file-pdf"></i>
                    <h4>Read Paper</h4>
                </a>
                
                <a href="https://github.com/TheGGLC" class="link-card" target="_blank">
                    <i class="fab fa-github"></i>
                    <h4>GitHub</h4>
                </a>
                
                <a href="#" class="link-card">
                    <i class="fas fa-video"></i>
                    <h4>Video</h4>
                </a>
                
                <a href="./resources/slides/FDG-GGLC-presentation.pdf" class="link-card">
                    <i class="fas fa-chalkboard"></i>
                    <h4>Slides</h4>
                </a>
            </div>
        </section>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
        // Draw maze comparison example
        function drawMazeComparison() {
            const canvas = document.getElementById('maze-comparison');
            const ctx = canvas.getContext('2d');
            ctx.translate(40, 0);
            const tileSize = 10;
            
            // Simple maze - solvable
            const solvableMaze = [
                [1,1,1,1,1,1,1],
                [1,2,0,0,1,0,1],
                [1,1,1,0,1,0,1], // Key section: Open path (0) at [2,3]
                [1,0,0,0,1,0,1],
                [1,0,1,1,1,0,1],
                [1,0,0,0,0,3,1],
                [1,1,1,1,1,1,1]
            ];
            
            // Draw solvable maze
            ctx.fillStyle = '#333';
            ctx.font = '11px Arial';
            
            for (let y = 0; y < solvableMaze.length; y++) {
                for (let x = 0; x < solvableMaze[y].length; x++) {
                    const tile = solvableMaze[y][x];
                    if (tile === 1) ctx.fillStyle = '#4a4a4a';
                    else if (tile === 2) ctx.fillStyle = '#4CAF50';
                    else if (tile === 3) ctx.fillStyle = '#FFD700';
                    else ctx.fillStyle = '#f8f9fa';
                    
                    ctx.fillRect(x * tileSize, y * tileSize + 20, tileSize - 1, tileSize - 1);
                }
            }
            
            // Draw path
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 2;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.moveTo(10, 35);
            ctx.lineTo(35, 35);
            ctx.moveTo(35, 35);
            ctx.lineTo(35, 55);
            ctx.moveTo(35, 55);
            ctx.lineTo(15, 55);
            ctx.moveTo(15, 65);
            ctx.lineTo(15, 55);
            ctx.moveTo(15, 55);
            ctx.lineTo(15, 75);
            ctx.lineTo(55, 75);
            ctx.stroke();
            ctx.setLineDash([]);

        
            
            // Unsolvable maze (with one extra wall)
            ctx.fillStyle = '#333';
            ctx.font = '11px Arial';
            ctx.fillText('Unsolvable Level', 145, 125);
            ctx.fillText('Solvable Level', 5, 125);

            
            const unsolvableMaze = [
                [1,1,1,1,1,1,1],
                [1,2,0,0,1,0,1],
                [1,1,1,1,1,0,1], // *** THE ONLY CHANGE: [2,3] is now '1' (Wall) ***
                [1,0,0,0,1,0,1],
                [1,0,1,1,1,0,1],
                [1,0,0,0,0,3,1],
                [1,1,1,1,1,1,1]
            ];
            
            for (let y = 0; y < unsolvableMaze.length; y++) {
                for (let x = 0; x < unsolvableMaze[y].length; x++) {
                    const tile = unsolvableMaze[y][x];
                    // Highlight the changed tile
                    if (tile === 1) {
                        ctx.fillStyle = '#4a4a4a';
                    } else if (tile === 2) {
                        ctx.fillStyle = '#4CAF50';
                    } else if (tile === 3) {
                        ctx.fillStyle = '#FFD700';
                    } else {
                        ctx.fillStyle = '#f8f9fa';
                    }
                    
                    ctx.fillRect(150 + x * tileSize, y * tileSize + 20, tileSize - 1, tileSize - 1);
                }
            }
            
            // Draw blocked path
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.lineTo(165, 35);
            ctx.lineTo(185, 35);
            ctx.lineTo(185, 40);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw X to show blocked
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(180, 40);
            ctx.lineTo(190, 50);
            ctx.moveTo(190, 40);
            ctx.lineTo(180, 50);
            ctx.stroke();
            
            // Add legend
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.fillText('ðŸŸ© Start  ðŸŸ¨ Goal  â¬› Wall', 50, 8);
        }

        // Initialize maze comparison
        drawMazeComparison();

        // Draw adversarial example comparison
        function drawAdversarialExample() {
            const canvas = document.getElementById('adversarial-demo');
            const ctx = canvas.getContext('2d');
            
            // Draw original "panda" image (simplified representation)
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, 140, 150);
            
            // Draw a simple panda face
            ctx.fillStyle = '#000';
            // Ears
            ctx.beginPath();
            ctx.arc(40, 40, 15, 0, Math.PI * 2);
            ctx.arc(100, 40, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Head
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(70, 70, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(55, 65, 8, 0, Math.PI * 2);
            ctx.arc(85, 65, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Nose
            ctx.beginPath();
            ctx.arc(70, 80, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Panda', 70, 145);
            
            // Draw arrow
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(145, 75);
            ctx.lineTo(155, 75);
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(152, 70);
            ctx.lineTo(160, 75);
            ctx.lineTo(152, 80);
            ctx.closePath();
            ctx.fillStyle = '#667eea';
            ctx.fill();
            
            // Draw "adversarial" version with noise
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(160, 0, 140, 150);
            
            // Add some noise pixels
            for(let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(${Math.random()*100}, ${Math.random()*100}, ${Math.random()*100}, 0.2)`;
                ctx.fillRect(160 + Math.random()*140, Math.random()*110, 2, 2);
            }
            
            // Draw same panda (showing it's still recognizable)
            ctx.fillStyle = '#000';
            // Ears
            ctx.beginPath();
            ctx.arc(200, 40, 15, 0, Math.PI * 2);
            ctx.arc(260, 40, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Head
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(230, 70, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(215, 65, 8, 0, Math.PI * 2);
            ctx.arc(245, 65, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Nose
            ctx.beginPath();
            ctx.arc(230, 80, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Still Panda!', 230, 145);
        }

        // Initialize adversarial example
        drawAdversarialExample();

        // Game level data and visualization code
        const TILE_TYPES = {
            EMPTY: 0,
            WALL: 1,
            PLAYER: 2,
            GOAL: 3,
            KEY: 4,
            DOOR: 5,
            CRATE: 6,
            CRATE_GOAL: 7,
            PLATFORM: 8,
            SPIKE: 9
        };

        const TILE_COLORS = {
            [TILE_TYPES.EMPTY]: '#f8f9fa',
            [TILE_TYPES.WALL]: '#4a4a4a',
            [TILE_TYPES.PLAYER]: '#4CAF50',
            [TILE_TYPES.GOAL]: '#FFD700',
            [TILE_TYPES.KEY]: '#FF6B6B',
            [TILE_TYPES.DOOR]: '#8B4513',
            [TILE_TYPES.CRATE]: '#CD853F',
            [TILE_TYPES.CRATE_GOAL]: '#FFA500',
            [TILE_TYPES.PLATFORM]: '#8B7355',
            [TILE_TYPES.SPIKE]: '#DC143C'
        };

        // Sample levels - now platformer levels
        const solvableLevel = [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,3,0],
            [0,0,0,0,0,0,0,8,8,8],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,8,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,8,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [2,0,8,0,0,0,0,0,0,0],
            [8,8,8,0,0,0,0,0,0,0]
        ];

        const unsolvableLevel = [
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,3,0],
            [0,0,0,0,0,0,0,8,8,8],
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],  // Removed platform tile here
            [0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,8,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0],
            [2,0,8,0,0,0,0,0,0,0],
            [8,8,8,0,0,0,0,0,0,0]
        ];

        const solvablePath = [
            {x: 0, y: 8, jumping: false},
            {x: 2, y: 8, jumping: true},
            {x: 3, y: 6, jumping: false},
            {x: 4, y: 6, jumping: true},
            {x: 4.5, y: 4, jumping: false},
            {x: 5, y: 4, jumping: true},
            {x: 6, y: 2, jumping: false},
            {x: 7, y: 2, jumping: true},
            {x: 8, y: 1, jumping: false},
        ];

        const unsolvablePath = [
            {x: 0, y: 8, jumping: false},
            {x: 2, y: 8, jumping: true},
            {x: 3, y: 6, jumping: false},
            {x: 4, y: 6, jumping: true},
            {x: 4, y: 7, jumping: false, falling: true},
            {x: 4, y: 8, jumping: false, falling: true},
            {x: 4, y: 9, jumping: false, stuck: false},
            {x: 4, y: 10, jumping: false, stuck: true}
        ];

        class LevelVisualizer {
            constructor(canvasId, levelData, path) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.level = levelData;
                this.path = path;
                this.tileSize = 32;
                this.currentPathIndex = -1;
                this.animating = false;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98D8E8');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw tiles
                for (let y = 0; y < this.level.length; y++) {
                    for (let x = 0; x < this.level[y].length; x++) {
                        const tile = this.level[y][x];
                        
                        if (tile === TILE_TYPES.PLATFORM || tile === TILE_TYPES.WALL) {
                            // Draw platform with grass on top
                            this.ctx.fillStyle = '#8B4513';
                            this.ctx.fillRect(x * this.tileSize, y * this.tileSize, 
                                            this.tileSize, this.tileSize);
                            this.ctx.fillStyle = '#228B22';
                            this.ctx.fillRect(x * this.tileSize, y * this.tileSize, 
                                            this.tileSize, 4);
                        } else if (tile === TILE_TYPES.PLAYER) {
                            // FIX: Adjust the Y coordinate UP by half a tile size (this.tileSize / 2).
                            // This ensures the player is standing on the tile surface, 
                            // not centered in the tile space.
                            if (!this.animating) {
                                this.drawPlayer(x * this.tileSize, y * this.tileSize + this.tileSize / 4);
                            }
                        } else if (tile === TILE_TYPES.GOAL) {
                            this.drawGoal(x * this.tileSize, y * this.tileSize);
                        }
                    }
                }
                
                // Draw path if animating
                if (this.currentPathIndex >= 0 && this.path.length > 0) {
                    const currentPos = this.path[Math.min(this.currentPathIndex, this.path.length - 1)];
                    
                    // Draw jumping arcs
                    this.ctx.strokeStyle = '#667eea';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([4, 4]);
                    this.ctx.beginPath();
                    
                    for (let i = 0; i <= Math.min(this.currentPathIndex, this.path.length - 1); i++) {
                        const point = this.path[i];
                        const x = point.x * this.tileSize + this.tileSize / 2;
                        const y = point.y * this.tileSize;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            const prevPoint = this.path[i - 1];
                            if (point.jumping) {
                                // Draw arc for jump - use the new y for prevY and midY calculations
                                const prevX = prevPoint.x * this.tileSize + this.tileSize / 2;
                                const prevY = prevPoint.y * this.tileSize; // FIXED Y
                                const midX = (prevX + x) / 2;
                                const midY = Math.min(prevY, y) - 20;
                                this.ctx.quadraticCurveTo(midX, midY, x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    // Draw character at current position
                    this.drawPlayer(currentPos.x * this.tileSize, 
                                currentPos.y * this.tileSize - this.tileSize / 2, // FIX 2: Shift Y up by half a tile size
                                currentPos.stuck, currentPos.falling);
                }
            }

            drawPlayer(x, y, stuck = false, falling = false) {
                this.ctx.fillStyle = stuck ? '#FF6B6B' : '#4CAF50';
                this.ctx.fillRect(x + 8, y + 8, 16, 16);
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                const emoji = stuck ? 'ðŸ˜µ' : (falling ? 'ðŸ˜°' : 'ðŸ˜Š');
                this.ctx.fillText(emoji, x + this.tileSize/2, y + this.tileSize/2);
            }

            drawGoal(x, y) {
                // Draw flag pole
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(x + 14, y + 8, 4, 20);
                // Draw flag
                this.ctx.fillStyle = '#FF0000';
                this.ctx.beginPath();
                this.ctx.moveTo(x + 18, y + 8);
                this.ctx.lineTo(x + 30, y + 14);
                this.ctx.lineTo(x + 18, y + 20);
                this.ctx.closePath();
                this.ctx.fill();
            }

            animatePath() {
                if (this.animating) return;
                this.animating = true;
                this.currentPathIndex = -1;
                
                const animate = () => {
                    if (this.currentPathIndex < this.path.length - 1) {
                        this.currentPathIndex++;
                        this.draw();
                        setTimeout(() => animate(), 400);
                    } else {
                        this.animating = false;
                    }
                };
                animate();
            }

            reset() {
                this.currentPathIndex = -1;
                this.animating = false;
                this.draw();
            }
        }

        // Initialize level visualizers
        const solvableViz = new LevelVisualizer('solvable-level', solvableLevel, solvablePath);
        const unsolvableViz = new LevelVisualizer('unsolvable-level', unsolvableLevel, unsolvablePath);

        solvableViz.draw();
        unsolvableViz.draw();

        // Button handlers
        document.getElementById('play-solvable').addEventListener('click', () => {
            solvableViz.animatePath();
        });

        document.getElementById('reset-solvable').addEventListener('click', () => {
            solvableViz.reset();
        });

        document.getElementById('play-unsolvable').addEventListener('click', () => {
            unsolvableViz.animatePath();
        });

        document.getElementById('reset-unsolvable').addEventListener('click', () => {
            unsolvableViz.reset();
        });

        // Draw mini game demos
        function drawMiniGame(canvasId, gameType) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const tileSize = 20;
            
            // Simple representations for each game
            const games = {
                'cave': [
                    [1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,1,0,0,0,0,3,1],
                    [1,1,0,1,0,1,1,1,0,1],
                    [1,0,0,0,0,0,0,1,0,1],
                    [1,0,1,1,1,1,0,1,0,1],
                    [1,0,0,0,0,0,0,0,0,1],
                    [1,1,0,1,1,1,1,1,0,1],
                    [1,2,0,0,0,0,0,0,0,1],
                    [1,1,1,0,0,4,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1]
                ],
                'platform': [
                    [0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,3,0],
                    [0,0,0,0,0,8,8,8,8,8],
                    [0,0,0,8,8,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0],
                    [0,8,8,0,0,0,0,0,0,0],
                    [0,0,0,0,0,8,8,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0],
                    [8,8,8,0,0,0,0,0,8,8],
                    [2,0,0,0,9,9,0,0,0,0]
                ],
                'crates': [
                    [1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,0,0,0,1],
                    [1,0,2,0,0,0,0,0,0,1],
                    [1,0,0,6,0,0,0,0,0,1],
                    [1,0,0,0,0,7,0,0,0,1],
                    [1,0,0,0,0,0,0,6,0,1],
                    [1,0,0,0,7,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1]
                ],
                'vertical': [
                    [0,0,0,1,0,0,1,0,0,0],
                    [0,0,0,1,3,0,1,0,0,0],
                    [0,0,0,1,8,8,1,0,0,0],
                    [0,0,0,1,0,0,1,0,0,0],
                    [0,0,8,8,0,0,8,8,0,0],
                    [0,0,0,1,0,0,1,0,0,0],
                    [0,8,8,1,0,0,1,8,8,0],
                    [0,0,0,1,0,0,1,0,0,0],
                    [8,8,8,1,0,0,1,8,8,8],
                    [2,0,0,0,0,0,0,0,0,0]
                ]
            };
            
            const level = games[gameType];
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < level.length; y++) {
                for (let x = 0; x < level[y].length; x++) {
                    const tile = level[y][x];
                    ctx.fillStyle = TILE_COLORS[tile];
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                }
            }
        }

        // Initialize mini game demos
        // drawMiniGame('cave-demo', 'cave');
        // drawMiniGame('platform-demo', 'platform');
        // drawMiniGame('crates-demo', 'crates');
        // drawMiniGame('vertical-demo', 'vertical');

        // Placeholder for game playing
        function playGame(gameType) {
            alert(`Interactive ${gameType} game would load here. In the full implementation, this would be a playable mini-game!`);
        }

        // Robustness plot

        function updateRobustnessPlot(sliderVal) {

            // Data from Table 3 in the paper
        const robustnessData = {
            'CIFAR-10': [0.0, 0.0, 0.1, 2.9, 6.7, 12.4, 12.8, 14.4, 18.9],
            'MNIST': [0.0, 0.0, 0.1, 1.6, 3.7, 5.8, 6.2, 6.1, 10.1],
            'cave': [0.0, 0.7, 2.3, 24.3, 29.6, 32.6, 32.6, 35.2, 36.2],
            'platform': [0.0, 0.0, 0.0, 2.0, 5.9, 12.5, 14.1, 21.2, 28.1],
            'crates': [0.0, 0.0, 0.3, 2.5, 6.0, 13.1, 15.3, 20.8, 25.8],
            'vertical': [0.0, 0.0, 0.1, 1.1, 3.2, 5.6, 6.7, 10.3, 15.9]
        };
        
        const radiusValues = [0.00001, 0.00005, 0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1];
        
        // Calculate average for each dataset to sort by (highest first)
        const datasetAvgs = Object.entries(robustnessData).map(([name, values]) => ({
            name,
            values,
            avg: values.reduce((a, b) => a + b, 0) / values.length
        }));
        
        // Sort by average descending (highest values first in tooltip)
        datasetAvgs.sort((a, b) => b.avg - a.avg);
        
        // Color palette
        const colors = {
            'cave': '#e41a1c',
            'platform': '#377eb8',
            'crates': '#4daf4a',
            'vertical': '#984ea3',
            'CIFAR-10': '#ff7f00',
            'MNIST': '#a65628'
        };
        
        // Create traces in sorted order
        const traces = datasetAvgs.map(({ name, values }) => ({
            x: radiusValues,
            y: values,
            type: 'scatter',
            mode: 'lines+markers',
            name: name,
            line: {
                width: ['cave', 'platform', 'crates', 'vertical'].includes(name) ? 3 : 2,
                color: colors[name]
            },
            marker: {
                size: 6,
                color: colors[name]
            },
            hovertemplate: `<b>${name}</b>: %{y:.1f}%<extra></extra>`
        }));
        
        const layout = {
            title: {
                text: 'Non-Robustness Comparison (Higher = More Sensitive)',
                font: { size: 16 }
            },
            xaxis: {
                title: 'Radius (r)',
                type: 'log',
                range: [-5, -0.8],
                gridcolor: '#e0e0e0'
            },
            yaxis: {
                title: 'Non-Robustness (%)',
                range: [0, 40],
                gridcolor: '#e0e0e0'
            },
            legend: {
                x: 0.02,
                y: 0.98,
                bgcolor: 'rgba(255,255,255,0.8)'
            },
            hovermode: 'x unified',
            hoverlabel: {
                bgcolor: 'white',
                bordercolor: '#ccc'
            },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white'
        };
        
        const config = {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['lasso2d', 'select2d']
        };
        
        Plotly.newPlot('robustness-plot', traces, layout, config);
        }
        // Initialize plot
        updateRobustnessPlot(10);

        // Embedding visualization
        function createEmbeddingPlot() {
            // Simulated UMAP embeddings for demonstration
            const numPoints = 200;
            const data = [];
            
            // Generate clusters for each game type
            const games = ['Cave', 'Platform', 'Crates', 'Vertical'];
            const centers = [
                {x: -5, y: 5}, {x: 5, y: 5}, {x: -5, y: -5}, {x: 5, y: -5}
            ];
            
            games.forEach((game, i) => {
                for (let j = 0; j < numPoints/4; j++) {
                    const solvable = Math.random() > 0.3;
                    const x = centers[i].x + (Math.random() - 0.5) * 4;
                    const y = centers[i].y + (Math.random() - 0.5) * 4;
                    
                    data.push({
                        x: x,
                        y: y,
                        game: game,
                        solvable: solvable,
                        color: solvable ? 'blue' : 'red',
                        text: `${game} - ${solvable ? 'Solvable' : 'Unsolvable'}`
                    });
                }
            });
            
            const solvableData = data.filter(d => d.solvable);
            const unsolvableData = data.filter(d => !d.solvable);
            
            const trace1 = {
                x: solvableData.map(d => d.x),
                y: solvableData.map(d => d.y),
                mode: 'markers',
                type: 'scatter',
                name: 'Solvable',
                text: solvableData.map(d => d.text),
                marker: {
                    size: 8,
                    color: '#4CAF50',
                    opacity: 0.6
                }
            };
            
            const trace2 = {
                x: unsolvableData.map(d => d.x),
                y: unsolvableData.map(d => d.y),
                mode: 'markers',
                type: 'scatter',
                name: 'Unsolvable',
                text: unsolvableData.map(d => d.text),
                marker: {
                    size: 8,
                    color: '#f44336',
                    opacity: 0.6
                }
            };
            
            const layout = {
                title: 'UMAP Embedding of Game Levels (CLIP Features)',
                xaxis: {
                    title: 'UMAP Dimension 1',
                    zeroline: false
                },
                yaxis: {
                    title: 'UMAP Dimension 2',
                    zeroline: false
                },
                hovermode: 'closest',
                showlegend: true
            };
            
            Plotly.newPlot('embedding-plot', [trace1, trace2], layout, {responsive: true});
        }

        // Initialize embedding plot
        createEmbeddingPlot();

        // Add smooth scrolling for better UX
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>